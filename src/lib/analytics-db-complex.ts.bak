/**
 * Phase 3: Advanced Analytics Data Layer
 * Sophisticated queries for welfare trend analysis and reporting
 */

import { appCache, cacheConfig, CacheKeys } from './cache';
import { query } from './employee-welfare-db';
import OptimizedDBPool from './db-pool';

// Analytics Types
export interface WelfareTrend {
  month: Date;
  totalActivities: number;
  completedActivities: number;
  overdueActivities: number;
  activeEmployees: number;
  averageIntervalDays: number;
  completionRate: number;
  completionGrowth: number;
  activityGrowth: number;
}

export interface EmployeeRiskScore {
  employeeId: string;
  employeeName: string;
  nextDue: Date;
  totalActivities: number;
  lastActivityDate: Date | null;
  overdueCount: number;
  completedCount: number;
  averageIntervalDays: number;
  riskScore: number;
  riskLevel: 'Critical' | 'High' | 'Medium' | 'Low';
  recommendation: string;
  daysSinceLastActivity: number | null;
}

export interface PerformanceMetrics {
  summary: {
    totalActivities: number;
    completedActivities: number;
    overdueActivities: number;
    employeesWithActivity: number;
    averageCompletionDays: number;
    overallCompletionRate: number;
  };
  patterns: {
    weekdayActivities: number;
    weekendActivities: number;
    weekdayPercentage: number;
  };
  activityTypes: {
    welfareCalls: number;
    welfareVisits: number;
    mentalHealthChecks: number;
  };
  weeklyBreakdown: Array<{
    week: number;
    activities: number;
    completionRate: number;
  }>;
}

export class WelfareAnalytics {

  /**
   * Get welfare activity trends over specified months
   */
  static async getWelfareTrends(months: number = 6): Promise<WelfareTrend[]> {
    const cacheKey = AnalyticsCacheKeys.trends(months);
    const cached = appCache.get<WelfareTrend[]>(cacheKey);
    
    if (cached) {
      console.log(`📦 Cache hit: welfare trends (${months} months)`);
      return cached;
    }

    console.log(`� Calculating welfare trends for ${months} months...`);
    
    try {
      // Simplified query without advanced window functions
      const result = await query(`
        SELECT 
          TO_CHAR(activity_date, 'YYYY-MM-01')::date as month,
          COUNT(*) as total_activities,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_activities,
          COUNT(CASE WHEN status = 'overdue' THEN 1 END) as overdue_activities,
          COUNT(DISTINCT employee_id) as active_employees,
          ROUND((COUNT(CASE WHEN status = 'completed' THEN 1 END)::float / NULLIF(COUNT(*), 0)) * 100, 1) as completion_rate,
          14 as avg_interval_days
        FROM welfare_activities
        WHERE activity_date >= CURRENT_DATE - INTERVAL '${months} months'
        GROUP BY TO_CHAR(activity_date, 'YYYY-MM-01')::date
        ORDER BY month DESC
      `);

      const trends = result.rows.map(row => ({
        month: row.month,
        totalActivities: parseInt(row.total_activities),
        completedActivities: parseInt(row.completed_activities),
        overdueActivities: parseInt(row.overdue_activities),
        activeEmployees: parseInt(row.active_employees),
        averageIntervalDays: parseFloat(row.avg_interval_days) || 14,
        completionRate: parseFloat(row.completion_rate) || 0,
        completionGrowth: 0, // Simplified - no growth calculation for now
        activityGrowth: 0    // Simplified - no growth calculation for now
      }));

      // Cache for 1 hour - trends don't change frequently
      appCache.set(cacheKey, trends, 60 * 60 * 1000);
      
      return trends;
    } catch (error) {
      console.error('Error calculating welfare trends:', error);
      // Return default data if query fails
      return [{
        month: new Date(),
        totalActivities: 0,
        completedActivities: 0,
        overdueActivities: 0,
        activeEmployees: 0,
        averageIntervalDays: 14,
        completionRate: 0,
        completionGrowth: 0,
        activityGrowth: 0
      }];
    }
  }

  /**
   * Calculate employee risk scores for predictive analytics
   */
  static async getEmployeeRiskScores(): Promise<EmployeeRiskScore[]> {
    const cacheKey = 'analytics:risk-scores';
    const cached = appCache.get<any>(cacheKey);
    
    if (cached) {
      console.log('📦 Cache hit: employee risk scores');
      return cached;
    }

    console.log('🎯 Calculating employee risk scores...');

    const result = await OptimizedDBPool.query(`
      WITH employee_metrics AS (
        SELECT 
          e.id,
          e.name,
          e.active,
          COALESCE(ws.next_welfare_due, e.created_at + INTERVAL '14 days') as next_due,
          COUNT(wa.id) as total_activities,
          MAX(wa.activity_date) as last_activity_date,
          AVG(CASE 
            WHEN wa.activity_date <= wa.activity_date - INTERVAL '14 days' 
            THEN EXTRACT(DAY FROM wa.activity_date - LAG(wa.activity_date) OVER (
              PARTITION BY e.id ORDER BY wa.activity_date
            ))
            ELSE 14
          END) as avg_interval_days,
          COUNT(CASE WHEN wa.status = 'overdue' THEN 1 END) as overdue_count,
          COUNT(CASE WHEN wa.status = 'completed' THEN 1 END) as completed_count
        FROM employees e
        LEFT JOIN welfare_schedules ws ON e.id = ws.employee_id
        LEFT JOIN welfare_activities wa ON e.id = wa.employee_id
        WHERE e.active = true
        GROUP BY e.id, e.name, e.active, ws.next_welfare_due, e.created_at
      ),
      risk_calculations AS (
        SELECT 
          id,
          name,
          active,
          next_due,
          total_activities,
          last_activity_date,
          overdue_count,
          completed_count,
          COALESCE(avg_interval_days, 14) as avg_interval_days,
          -- Risk factors calculation (0-10 scale)
          CASE 
            WHEN last_activity_date IS NULL THEN 8.0  -- No activity history
            WHEN CURRENT_DATE - last_activity_date > 21 THEN 9.0  -- Very overdue
            WHEN CURRENT_DATE - last_activity_date > 14 THEN 7.0  -- Overdue
            WHEN next_due < CURRENT_DATE THEN 6.0  -- Due now
            WHEN next_due <= CURRENT_DATE + INTERVAL '3 days' THEN 4.0  -- Due soon
            WHEN avg_interval_days > 21 THEN 5.0  -- Inconsistent pattern
            WHEN overdue_count > 3 THEN 6.0  -- History of overdue
            WHEN (completed_count::float / NULLIF(total_activities, 0)) < 0.8 THEN 5.0  -- Low completion rate
            ELSE 2.0  -- Low risk
          END as risk_score
        FROM employee_metrics
      )
      SELECT 
        id,
        name,
        next_due,
        total_activities,
        last_activity_date,
        overdue_count,
        completed_count,
        avg_interval_days,
        risk_score,
        CASE 
          WHEN risk_score >= 8 THEN 'Critical'
          WHEN risk_score >= 6 THEN 'High'
          WHEN risk_score >= 4 THEN 'Medium'
          ELSE 'Low'
        END as risk_level,
        CASE 
          WHEN risk_score >= 8 THEN 'Immediate welfare check required'
          WHEN risk_score >= 6 THEN 'Schedule welfare check within 48 hours'
          WHEN risk_score >= 4 THEN 'Monitor closely, check due date'
          ELSE 'Continue regular schedule'
        END as recommendation
      FROM risk_calculations
      ORDER BY risk_score DESC, next_due ASC
    `);

    const riskScores = result.rows.map(row => ({
      employeeId: row.id,
      employeeName: row.name,
      nextDue: new Date(row.next_due),
      totalActivities: parseInt(row.total_activities) || 0,
      lastActivityDate: row.last_activity_date ? new Date(row.last_activity_date) : null,
      overdueCount: parseInt(row.overdue_count) || 0,
      completedCount: parseInt(row.completed_count) || 0,
      averageIntervalDays: parseFloat(row.avg_interval_days) || 14,
      riskScore: parseFloat(row.risk_score),
      riskLevel: row.risk_level,
      recommendation: row.recommendation,
      daysSinceLastActivity: row.last_activity_date 
        ? Math.floor((Date.now() - new Date(row.last_activity_date).getTime()) / (1000 * 60 * 60 * 24))
        : null
    }));

    // Cache for 2 hours - risk scores update based on activities
    appCache.set(cacheKey, riskScores, 2 * 60 * 60 * 1000);
    
    return riskScores;
  }

  /**
   * Get performance metrics for teams/departments
   */
  static async getPerformanceMetrics(dateRange: { start: Date; end: Date }): Promise<PerformanceMetrics> {
    const cacheKey = `analytics:performance:${dateRange.start.toISOString()}:${dateRange.end.toISOString()}`;
    const cached = appCache.get<any>(cacheKey);
    
    if (cached) {
      console.log('📦 Cache hit: performance metrics');
      return cached;
    }

    console.log('📈 Calculating performance metrics...');

    const result = await OptimizedDBPool.query(`
      WITH period_activities AS (
        SELECT 
          wa.*,
          e.name as employee_name,
          EXTRACT(WEEK FROM wa.activity_date) as week_number,
          EXTRACT(DOW FROM wa.activity_date) as day_of_week
        FROM welfare_activities wa
        JOIN employees e ON wa.employee_id = e.id
        WHERE wa.activity_date BETWEEN $1 AND $2
      ),
      performance_summary AS (
        SELECT 
          COUNT(*) as total_activities,
          COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_activities,
          COUNT(CASE WHEN status = 'overdue' THEN 1 END) as overdue_activities,
          COUNT(DISTINCT employee_id) as employees_with_activity,
          AVG(CASE WHEN status = 'completed' THEN 
            EXTRACT(DAY FROM activity_date - created_at) 
          END) as avg_completion_days,
          -- Weekly patterns
          COUNT(CASE WHEN day_of_week IN (1,2,3,4,5) THEN 1 END) as weekday_activities,
          COUNT(CASE WHEN day_of_week IN (0,6) THEN 1 END) as weekend_activities,
          -- Activity type distribution
          COUNT(CASE WHEN welfare_type = 'Welfare Call' THEN 1 END) as welfare_calls,
          COUNT(CASE WHEN welfare_type = 'Welfare Visit' THEN 1 END) as welfare_visits,
          COUNT(CASE WHEN welfare_type = 'Mental Health Check' THEN 1 END) as mental_health_checks
        FROM period_activities
      ),
      weekly_breakdown AS (
        SELECT 
          week_number,
          COUNT(*) as activities,
          ROUND(AVG(CASE WHEN status = 'completed' THEN 100.0 ELSE 0.0 END), 1) as completion_rate
        FROM period_activities
        GROUP BY week_number
        ORDER BY week_number
      )
      SELECT 
        ps.*,
        (SELECT json_agg(json_build_object('week', week_number, 'activities', activities, 'completionRate', completion_rate))
         FROM weekly_breakdown) as weekly_data
      FROM performance_summary ps
    `, [dateRange.start.toISOString(), dateRange.end.toISOString()]);

    const metrics = result.rows[0];
    
    const performanceData = {
      summary: {
        totalActivities: parseInt(metrics.total_activities) || 0,
        completedActivities: parseInt(metrics.completed_activities) || 0,
        overdueActivities: parseInt(metrics.overdue_activities) || 0,
        employeesWithActivity: parseInt(metrics.employees_with_activity) || 0,
        averageCompletionDays: parseFloat(metrics.avg_completion_days) || 0,
        overallCompletionRate: metrics.total_activities > 0 
          ? Math.round((metrics.completed_activities / metrics.total_activities) * 100)
          : 0
      },
      patterns: {
        weekdayActivities: parseInt(metrics.weekday_activities) || 0,
        weekendActivities: parseInt(metrics.weekend_activities) || 0,
        weekdayPercentage: metrics.total_activities > 0
          ? Math.round((metrics.weekday_activities / metrics.total_activities) * 100)
          : 0
      },
      activityTypes: {
        welfareCalls: parseInt(metrics.welfare_calls) || 0,
        welfareVisits: parseInt(metrics.welfare_visits) || 0,
        mentalHealthChecks: parseInt(metrics.mental_health_checks) || 0
      },
      weeklyBreakdown: metrics.weekly_data || []
    };

    // Cache for 4 hours - performance metrics are historical
    appCache.set(cacheKey, performanceData, 4 * 60 * 60 * 1000);
    
    return performanceData;
  }

  /**
   * Generate executive summary for dashboard
   */
  static async getExecutiveSummary() {
    const cacheKey = 'analytics:executive-summary';
    const cached = appCache.get<any>(cacheKey);
    
    if (cached) {
      console.log('📦 Cache hit: executive summary');
      return cached;
    }

    console.log('🎖️ Generating executive summary...');

    // Get current month performance
    const currentMonth = new Date();
    currentMonth.setDate(1); // First day of current month
    const nextMonth = new Date(currentMonth);
    nextMonth.setMonth(nextMonth.getMonth() + 1);

    const [trends, riskScores, performance] = await Promise.all([
      this.getWelfareTrends(3), // Last 3 months
      this.getEmployeeRiskScores(),
      this.getPerformanceMetrics({ start: currentMonth, end: nextMonth })
    ]);

    const summary = {
      overallHealth: {
        totalEmployees: riskScores.length,
        highRiskEmployees: riskScores.filter((emp: EmployeeRiskScore) => emp.riskLevel === 'Critical' || emp.riskLevel === 'High').length,
        completionRate: performance.summary.overallCompletionRate,
        trend: trends.length > 1 
          ? trends[0].completionGrowth > 0 ? 'improving' : trends[0].completionGrowth < 0 ? 'declining' : 'stable'
          : 'stable'
      },
      keyMetrics: {
        activitiesThisMonth: performance.summary.totalActivities,
        overdueActivities: performance.summary.overdueActivities,
        averageResponseTime: performance.summary.averageCompletionDays,
        employeeEngagement: Math.round((performance.summary.employeesWithActivity / riskScores.length) * 100)
      },
      alerts: [
        ...(riskScores.filter((emp: EmployeeRiskScore) => emp.riskLevel === 'Critical').slice(0, 3).map((emp: EmployeeRiskScore) => ({
          type: 'critical',
          message: `${emp.employeeName} requires immediate welfare attention`,
          employeeId: emp.employeeId,
          action: 'Schedule welfare check'
        }))),
        ...(performance.summary.overdueActivities > 5 ? [{
          type: 'warning', 
          message: `${performance.summary.overdueActivities} overdue welfare activities require attention`,
          action: 'Review overdue list'
        }] : []),
        ...(trends.length > 1 && trends[0].completionGrowth < -10 ? [{
          type: 'warning',
          message: `Completion rate declined by ${Math.abs(trends[0].completionGrowth)}% this month`,
          action: 'Investigate completion issues'
        }] : [])
      ],
      recommendations: [
        riskScores.filter((emp: EmployeeRiskScore) => emp.riskLevel === 'High').length > 0 
          ? `Focus on ${riskScores.filter((emp: EmployeeRiskScore) => emp.riskLevel === 'High').length} high-risk employees`
          : 'Maintain current welfare schedule',
        performance.patterns.weekendActivities > performance.patterns.weekdayActivities * 0.3
          ? 'Consider adjusting weekend welfare coverage'
          : 'Good weekday/weekend balance maintained',
        trends.length > 0 && trends[0].averageIntervalDays > 16
          ? 'Consider reducing welfare check intervals'
          : 'Welfare frequency is appropriate'
      ].filter(Boolean)
    };

    // Cache for 1 hour - executive summary updates frequently
    appCache.set(cacheKey, summary, 60 * 60 * 1000);
    
    return summary;
  }
}

// Enhanced cache keys for analytics
export const AnalyticsCacheKeys = {
  trends: (months: number) => `analytics:trends:${months}months`,
  riskScores: () => 'analytics:risk-scores',
  performance: (start: Date, end: Date) => `analytics:performance:${start.toISOString()}:${end.toISOString()}`,
  executiveSummary: () => 'analytics:executive-summary'
} as const;
